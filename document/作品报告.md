

# 作品报告

[toc]

## 0 摘要

​		当下互联网快速发展，信息交互的需求爆炸式产生，各方逐渐形成了数据等于价值的共识，各类提供存储、计算能力的云服务因此不断出现。与此同时，云服务商提供的服务种类也应有尽有，而我们致力于实现一个文本的云存储系统，并提供给用户进行全文搜索的功能。

​		然而，伴随着隐私泄露频发的事实，数据的隐私安全问题成为了当下公众关注的热点。传统的云服务商往往通过数据加密存储以及基于权限控制的工业管理手段来向用户保障平台的安全性，从而让用户放心使用。然而，用户即使相信服务商，也难以信任服务商的每一个员工，更何况企业员工获取用户隐私的事件频频爆出。于是，倘若有一个云服务商能够向用户宣称：“你可以用我的服务，但不用相信我！”那么这影响是具有颠覆性的。因此这也是我们本次项目的目标，即实现一个不需要用户信任的全文搜索系统。

​		为了实现这个目的，当下已经存在一些解决方案。比如使用全同态加密来实现密文空间的搜索，或者使用可搜索加密来解决问题，然而这些方式虽然能保障云端数据的安全，但是无法兼得丰富的搜索功能与较高的搜索效率。而利用可信执行环境TEE，可以很好地解决以上问题，即保证安全的同时兼得功能与性能。因此我们的项目，创新性地基于TEE来实现密文空间的全文搜索。

​		我们通过借助开源框架Rust SGX SDK，来实现我们的系统，并围绕文本搜索引擎Tantivy构建了一个安全模型，将服务端的可信计算基TCB缩小至Intel制造的CPU。我们首先将Tantivy迁移至TEE环境，并对其进行了全面的改造和性能优化，包括与可信环境的适配，对不可信输入的检查，索引建立的改进，打分算法的优化等等。其次，我们设计了拟同态加密计算协议，以实现客户端与服务端可信区之间的安全通信。 最后，我们实现了客户端与服务端，并提供上传、在线浏览、删除、下载等基础功能，以及关键词搜索、复杂条件的搜索、模糊搜索等丰富的搜索功能。

​		通过完善的系统测试以及性能测试，包括搜索性能测试与压力测试，我们得出此系统有着极高的性能与可靠性，同时安全性以及功能的丰富性也得到了保障，具有极好的市场应用前景。

关键词：云计算、可信执行环境TEE、文本搜索、Tantivy

## 1 作品概述 

​		本节分为五个部分，第一部分为背景分析，分析了当下云存储、云计算的不安全问题以及我们希望实现一个不需要信任服务商的全文搜索系统；第二部分为相关工作现状，介绍了一些现有的解决方案及其不足；第三部分为我们的工作，介绍了我们基于可信执行环境来实现我们的系统；第四部分描述了我们项目的特色；第五部分为应用前景分析，无论是私人用户，还是诸如政府、军方等官方机构，我们实现的系统都有着很好的应用价值。

### 1.1 背景分析

> 云存储、云计算的安全性问题，如何实现在第三方平台的机密计算（全文搜索）

​    	随着通信技术的发展、传输速度的增加，以及数据文件的不断变大，个人电脑变得越来越难以胜任海量数据的处理。服务器等计算中心由于其强劲的性能备受青睐，外加之数据传输越来越便捷，云存储与云计算等技术正在蓬勃发展，其应用也在变得越来越广。调查显示，越来越多的企业与个人正在频繁地使用云存储服务，例如阿里云、amazon、iCloud等等。

​    	数据的使用与处理变得更加便捷，但是安全隐患也随之产生。用户的个人隐私数据在交付服务方(数据处理方)之后，这些个人隐私数据的安全性该如何保证。由于数据的处理过程完全在用户不可控的情形下进行，则即便是个人数据的有关权利被侵犯或者是数据遭到泄露，用户本人也无法及时全面的了解情况。若这些数据在云端被不法分子获取，用于一些危害用户安全和社会稳定的行为，则后果更为严重。另一方面，提供服务的开发商面临的问题是：若获取的用户隐私数据泄露，开发商在法律上是不是要承担一定责任；而隐私数据的处理过程和处理结果若被篡改，又应当由谁来承担责任？

​		仅仅因为服务器被黑客攻击这一单一原因导致的数据隐私泄露事件就不胜枚举发生。2018年就发生了FACEBOOK三千万用户的隐私数据泄露；圆通快递十亿条运单信息、万豪酒店五亿条开房信息泄露等等事件。这些服务器数据的泄露事件触目惊心。

​		数据泄露仅仅是云存储安全问题的其中之一。除了数据泄露之外，云存储与云计算还面临着身份、凭据和访问管理不当，系统漏洞，账户劫持，恶意内部人员，高级持续威胁（APTs）、幽灵（Spectre）、熔断（meltsown）等等威胁。

​		以账户劫持为例，CSA（Canadian Standards Association，加拿大标准协会）的一篇报告指出帐户或服务劫持并不新鲜，但云服务的出现带来了新的威胁。如果攻击者获得了对用户凭证的访问权，他们就可以监视用户活动和交易，操纵数据，返回伪造的信息，并将客户重定向到非法站点。帐户或服务实例可能成为攻击者的新依据。使用窃取的凭证，攻击者可以访问云计算服务的关键部分，从而破坏这些服务的机密性、完整性和可用性。Deep Dive 报告中的一个例子：Dirty Cow 高级持续威胁 (APT) 小组能够通过薄弱的审查或社会工程接管现有帐户，从而获得系统root权限。该报告建议对访问权限实行 “需要知道” 和 “需要访问” 策略，并对帐户接管策略进行社交工程训练。

​		综上所述，针对云服务这一过程，其存在用户数据的隐私与安全性无法得到保障、过程和结果可能存在不一致性（即某一步骤可能遭到篡改）等问题，而这也是我们希望解决的痛点。当然，针对这一问题，业界与学界已有不少解决方案。例如同态加密算法、姚期智院士提出的MPC（安全多方计算）等等。

​		同时，云服务的方向很多，我们着力于基于TEE环境实现一个安全高效的密文空间全文搜索系统。

### 1.2 相关工作现状

> 为了实现安全的全文搜索，当下的实现方案和研究进展

​		由前文提到，我们的目标是构建一个安全高效的密文空间全文搜索系统。

​		可搜索加密问题源于文献[1]：假设用户Alice试图将个人文件存放在一个诚实但具有好奇心的外部服务器，以降低本地资源开销。为保护文件隐私，须采用某种加密方式将文件加密后存储.使用传统分组密码，只有密钥拥有者才具备解密能力，意味着Alice在执行基于关键词的查询操作时，需要下载所有已上传的文件，完全解密后再检索,会带来两个问题：1、如果Alice在服务器上已存有大量文件，一一下载会占用大量网络带宽,可能造成服务器堵塞；2、对已下载的所有文件完全解密会占用大量本地计算资源，效率极低。

​		针对这一特殊的问题，业界与学界亦已有不少解决方案。例如可搜索加密算法、同态加密算法、安全多方计算等等。但这些算法或是功能相当受限，或是时间空间的复杂度高到当前的硬件基础无法接受。

​	1.2.1节中将对这些算法一一介绍。

​	1.2.2节中将介绍业界结合TEE的一些应用。

#### 1.2.1 基于传统密码学方案

> 同态加密、可搜索加密、安全多方计算，突出不足之处

##### 1.2.1.1 同态加密计算

​		同态加密是 Rivest 等人在 1978 年提出的一种加密方案。实现对加密数据的全同态计算对于云服务拥有者和用户来说，是非常有利用价值的功能。同态加密使得我们可以直接对密文进行运算，运算得到的结果和明文对应的运算得到的结果再加密是一致的。在 2009 年，IBM 的学者 Gentry 发明出了第一个全同态方案，提出了一个具有 自举性的同态加密方案可以转换为一个全同态加密方案，该方案可以支持任意深度电路的计算。从 2009 年到现在，学者们对 Gentry 同态加密算法方案进行了优化并实现了很多衍生方案。从理论上说，全同态加密算法可以从根本上解决数据第三方委托问题，这样可以直接将数据交给第三方运算，从而利用云端大规模的计算资源对隐私数 据进行处理。但是全同态加密方案有一些缺点，最重要的就是运算效率太低。虽然国内外学者提出了一些全同态加密的改进方案，但这些方案的实用性都不足够运用在实际平台中。Dijk 和 Gentry 等人提出的方案在现实生活的应用中，加密的速度非常慢，消耗比较大，所以，现在提出的各种全同态加密方案对于隐私保护计算仅仅停留在理论解决阶段，并不能在实际中大规模部署应用。

<img src="../image/image-20210430191902716.png" alt="image-20210430191902716" style="zoom:60%;" />

<p align="center">	全同态加密算法示意图</p>

​		以下为一定数据量大小在全同态加密算法下生成密钥所需的时间、生成的包的大小与解密所需的时间。

| **Dimension**  | **KeyGen** | **PK** **Size** | **Recryp** |
| -------------- | ---------- | --------------- | ---------- |
| 2048（100KB）  | 40  Sec    | 70MB            | 31  Sec    |
| 8196（400KB）  | 8  Min     | 285MB           | 3  Min     |
| 32768（1.6MB） | 2  Hours   | 2.3GB           | 30  Min    |

​		综上所述，同态加密算法可以用理论密码学确保其的绝对安全，并且可以对数据进行任意操作，具有强大的通用性；但由于其所需的时间与空间的接近于$10^5$倍的原有开销，实际的使用价值有限。

##### 1.2.1.2 可搜索加密算法

​		可搜索加密(searchable encryption，简称SE)，该技术要求只有合法用户才具备基于关键词检索的能力.随着研究的推进,其应用并不仅限于此:2004年,Boneh提出使用非对称可搜索加密(asymmetric searchable encryption,简称ASE)解决“不可信赖服务器路由”问题[2];最近兴起的云计算[3]将是SE的最佳应用平台,由于服务提供商的不可控性,用户必须应对存储到云端的个人数据可能泄密的威胁,SE提供的加密和密文直接检索功能使服务器无法窃听用户个人数据,但可以根据查询请求返回目标密文文件,这样既保证了用户数据的安全和隐私,又不会过分降低查询效率。

​		可搜索加密中又存在单用户模型、多对一模型、一对多模型和多对多模型，其解决策略也不尽相同，分为对称可搜索加密、非对称可搜索加密等，构造也分为SWP方案[1]、Z-IDX方案[4]和SSE-1方案[6]等等。

​		可搜索加密算法的优点主要在于时间和空间所需的复杂度都较低，以查询为例，仅需O（1）的时间即可完成检索。但其也有不少缺点：

1. 执行文件的添加或删除操作需要重新构建索引,时间开销较大。
2. 多关键词检索的条件下，需*O*(*n*)通信量,可能造成网络负载过重；且其多关键词检索方案的安全性通常依赖于某种数学难题,所依赖的数学难题的强弱也反映了方案安全性的高低。
3. 部分方案（如SSE）由于缺乏对细微文字以及格式错误的容忍，无法进行模糊关键词搜索。
4. 许多方案（如SSE）仅支持布尔检索(即,判断某个关键词是否存在于文件中)而不能追踪关键词与文件的相关度.对于查询返回结果,用户必须进行后处理:解密所有返回文件,以获取目标文件。而多用户单服务器模型下的查询结果排序问题至今未解决。

​		综上所述，可搜索加密算法的优点为搜索快速而高效，但是对于云盘类的需要频繁更新文件的应用场景，七每次需要重构索引的时间开销相当之大；且其对多关键词检索、模糊搜索等并没有有很好的支持。

##### 1.2.1.3 安全多方计算

​		安全多方计算最早是由华裔计算机科学家、图灵奖获得者姚启智院士通过百万富翁问题提出的。该问题表述为：两个百万富翁Alice和Bob想知道他们两个谁更富有，但他们都不想让对方知道自己财富的任何信息。在双方都不提供真实财富信息的情况下，如果比较两个人的财富多少，并给出可信证明。

​		安全多方计算技术框架如下图所示：

<img src="../image/image-20210430195024717.png" alt="image-20210430195024717" style="zoom:50%;" />

​		各个MPC参与节点地位相同，可以发起协同计算任务，也可以选择参与其他方发起的计算任务。路由寻址和计算逻辑传输由枢纽节点控制，寻找相关数据同时传输计算逻辑。各个MPC节点根据计算逻辑，在本地数据库完成数据提取、计算，并将输出计算结果路由到指定节点，从而多方节点完成协同计算任务，输出唯一性结果。整个过程各方数据全部在本地，并不提供给其他节点，在保证数据隐私的情况下，将计算结果反馈到整个计算任务系统，从而各方得到正确的数据反馈。

​		著名密码学专家 Goldwasser 曾经说过“在密码学研究领域中，安全多方计算今天所处的地位正如公钥密码学算法十年前所处的地位，而且它是一个极其重要的工具，它将 成为计算科学中不可替代的一部分。”Goldreich 等人进一步对安全多方计算进行了系统性研究，并从理论上证明了一般的安全多方计算问题是可解的，提出了安全多方 计算协议的安全性定义与模拟范例。但从计算效率的角度考虑，Goldreich 等人指出，使用通用的计算模型解决具体的安全多方计算问题是不实际的，安全多方计算协议本身不支持通用的计算模型，针对具体的问题应该研究具体的解决方案，另一方面，安全多方计算协议本身设计较为复杂，也成为了其大规模推广部署的一个关键瓶颈。

#### 1.2.2 基于可信执行环境TEE

> 阿里工作（为什么阿里做了而我们也在做? 它们还在研究中，侧重点不同balabala）

​		结合可信执行环境（Trust Exectuion Environment,TEE）的应用虽然尚未具规模（受限于额外的硬件开销与开发环境尚未很成熟），但由于其对于安全性、时空开销的较好平衡，许多大厂都已经在这个赛道上开始发力。以阿里云为例，其推出了物联网可信执行环境阿里云Link TEE，为物联网设备提供TEE安全框架和安全应用的全生命周期管理，提供符合Global Platform TEE标准接口的安全、可信执行环境。

​		其架构如下：

![img](https://img.alicdn.com/tfs/TB1Fb8HmeOSBuNjy0FdXXbDnVXa-1192-700.png)

​		根据其官网的介绍，阿里云Link TEE（Trusted Execution Environment）提供不同安全等级的可信保护，支持基于ARM Trustzone或T-Head的安全扩展技术提供硬件级别的可信根，也提供软件级别的保护方案。Link TEE产品可以为多个行业的设备提供安全应用场景，广泛应用于指纹识别、身份认证、电子支付、TEE-SIM、智能锁等安全应用。Link TEE提供安全基础架构和可信运行环境，构建安全增强服务。

​		其现已推出三款物联网TEE芯片：TEE Pro、TEE Cap与TEE Air，分别支持不同裁剪大小的系统，从桌面端的Linux、Andriod、AliOS到嵌入式设备的RT OS，一应俱全。

​		综上，阿里云也看到了TEE对于安全性、时空复杂度的高效平衡，正在大力推动相关的开发。我们的项目与其对比，我们着力于基于TEE的可搜索云服务的开发，并且使用的TEE环境为主机端的Intel SGX；而阿里着力于打造IoT设备的安全扩展技术，并且使用的TEE环境是ARM的TrustZONE。

### 1.3 我们的工作

​		如前所述，针对现有云存储、云计算的不安全问题，服务商往往难以赢得用户的信任，而我们致力于实现一个不需要用户信任的全文搜索系统。倘若用户直接将自己的数据本地加密后上传到服务器，自然无法进行全文的搜索，而利用同态加密、可搜索加密等技术可以解决这个问题，然而这些技术目前都有着较大的短板。而可信执行环境TEE，能很好地解决以上问题，因此我们借助TEE的较为成熟的实现，即Intel的SGX，来实现我们的系统。我们项目的核心工作，主要分为以下几点：

1. 利用开源框架Rust SGX SDK，将服务端划分为不可信区与可信区，不可信区的数据都以密文的形式存在，这些数据在可信区解密处理，而可信区的安全性由硬件保证。
2. 将文本搜索引擎Tantivy迁移至SGX环境，进行全面的改造和优化，包括索引建立的改进、打分算法的替换升级等等。
3. 设计了拟同态加密计算协议，实现客户端与服务端可信区之间的加密通信，保证在网络传输、服务端的不可信区中数据的安全性。
4. 用户可将自己的数据上传至服务端，进行下载、删除等基本操作。同时，我们提供了丰富的搜索功能，用户可进行关键词全文搜索、复杂条件搜索、通配符搜索、模糊搜索以及以上方式的组合搜索等等。
5. 我们针对此系统进行了全面的功能测试与性能测试，证明了此系统的可靠性；同时，我们进行了安全性的分析，在操作系统不可信的威胁模型下论证了侧信道攻击等潜在的威胁，并给出了相应的防御措施。

### 1.4 特色描述

1. 利用Intel的SGX，将服务端的可信计算基TCB缩小至CPU。与传统的威胁模型相比，操作系统等Ring0级别的软件被视为不可信的，解决了传统云服务商的不受信任问题，即实现了服务商的”你可以用我的服务，但不用相信我“。
2. 以Rust实现的文本搜索引擎Tantivy作为基础，将其迁移至SGX环境，并进行优化，包括多线程优化、索引存储结构优化等等。
3. 利用Intel SGX的远程认证功能以及数据本地密封功能，设计了客户端与服务端通信的拟同态加密计算协议，实现了客户端与服务端的加密安全通信，保护用户的数据在网络传输中以及在服务端不被窃取。
4. 用户可上传、下载、删除自己存储于云服务端的隐私数据，并支持全文搜索、复杂条件的搜索、模糊搜索等等。
5. 系统同时拥有高效的性能与安全的特性，解决了以往方案诸如全同态加密、可搜索加密等等的弊端。

### 1.5 应用前景分析

> 全文搜索的应用场景，政府、医疗、邮件……

​		由前文描述，我们所构建的系统为基于TEE的密文空间搜索系统，在服务端拥有Intel SGX区块的前提条件下（6代及以上的Intel cpu即支持SGX的扩展），具有用户无需信任服务器、支持多关键词搜索、模糊搜索等搜索，支持txt、pdf、docx等多种文本文件的管理与搜索。故本项目在对安全性较高、搜索时间性能要求严苛、搜索功能多样的应用场景下大有用武之地。

​		以医疗系统或是政府部门或是军方等以及邮件系统等对于文件隐私敏感性非常高的应用场景为例，由于本系统无需用户信任服务器，因为在服务器端所有数据都以加密的形式存在，仅仅在用户端与服务器的SGX的Enclave中存在明文数据，而SGX作为可信执行环境其安全性由Intel的硬件架构设计保证，恶意应用或是恶意的hypervisor无法绕过SGX访问Enclave内部的数据。换言之，以并不大的额外硬件开销换取的SGX接口保障了在不受信任的服务端下也能正常工作且不会泄露数据；同时，相较全同态加密、MPC等算法有着无可比拟的低得多的时空复杂度优势，相较可搜索加密算法则可以很好地支持索引的更新而不必整个重新构建，且对模糊搜索、多关键词搜索、结果排序也有着从架构上天然就更好的支持（Tantivy直接移植），也就意味着搜索结果的返回更快。

​		设想，在军方系统中可能存在着某一种对实时性要求非常高的查询系统（如导弹的GPS系统），其需要从存着海量数据的服务端中搜索所需的数据（例如导弹在某一点时需要对应的地图数据）。多数情况下为了保障安全，服务器当然也是需要是可信任的；但是假设非常不幸的，服务器后端的某一技术人员被敌军策反，或是该系统的某一部分被敌方黑客注入了恶意代码，此时服务器变得不再受信任，但军方可能此时并不知晓，仍然向该服务器请求数据，此时结合TEE的该系统就显得大有用武之地。在所有无需信任服务器的算法中，由于应用需求高实时性，MPC、全同态加密算法等时间复杂度很高的算法就首先会被pass；而可搜索加密虽然有着相同的很快的检索数据能力，但其由于对一些扩展搜索没有很好的支持；加之地图数据很可能会不时做一些小更新，每次都要重构整个索引文件是非常低效的。相较之下，基于TEE的密文空间搜索系统就是最好的选择。

​		本项目创新性地结合TEE可信执行环境并移植搜索引擎Tantivy，通过拟同态加密计算协议与Tantivy搜索引擎的通用性、低时空复杂度、搜索功能多样性特性相结合，解决现有的云服务中的搜索性能问题、模型通用性问题和协议逻辑复杂问题。本项目所设计实现的等效于密文空间搜索，以及相应的会话密钥协商、HTTPS等通信协议，完整地给出了一套在隐私数据分析处理的场景下的安全、高效、可扩展的支持多种搜索的加密云存储方案，具有较高的启发意义和实用价值。

## 2 作品设计与实现

> 官方：建议包括系统方案、实现原理、硬件框图、软件流程、功能、指标等

​		本节分为三个部分，第一部分为设计概述，简要说明了我们搜索系统的设计方案以及提供的功能；第二部分为技术原理，我们实现的系统主要使用的技术有Intel SGX以及文本搜索引擎Tantivy，我们在这一部分对这些技术的关键进行了说明；第三部分为系统实现，为了实现基于TEE的全文搜索系统，我们对Tantivy进行了SGX环境的移植与全面的改造，其次，为了实现客户端与服务端的安全通信，我们设计了拟同态加密计算协议，最后，我们给出了服务端与客户端的详细实现。

### 2.1 设计概述

#### 2.1.1 设计方案

​		本项目通过实现一个基于TEE的搜索系统，旨在为用户提供高效、安全的搜索与存储服务。用户可以上传自己的隐私数据至云平台，同时可进行全文搜索、复杂条件搜索以及模糊搜索。本项目的基础架构如下所示。

<img src="../image/截屏2021-05-03 下午1.48.39.png" alt="截屏2021-05-03 下午1.48.39" style="zoom:40%;" />

​		本项目的客户端使用开源前端框架Bootstrap完成，服务端的不可信区使用Web框架Beego进行开发，而服务端的可信区采用基于Rust实现的SGX SDK。其中，不可信区与可信区采用静态链接的方式。

​		其中，客户端浏览器主要使用Ajax与后端进行通信，其完成的功能主要包括数据的加解密。服务端不可信区主要起到传递数据以及数据库存取的作用，在这一环节中，所有数据都是密文的。在服务端的可信区中，我们主要使用了文本搜索引擎Tantivy以及百度的开源框架Rust SGX SDK。首先，我们将文本搜索引擎Tantivy迁移至SGX环境。针对SGX的特殊开发模型，我们对Tantivy进行了全面的改造，包括多线程的优化、索引存储结构的优化、打分算法的优化等等，同时对所有不可信输入进行严格的检查，以实现一个安全的搜索模型，使得可信计算基缩小至CPU。

​		其次，为了实现客户端与服务端可信区的安全通信，我们利用远程认证技术、数据密封技术，实现了一个拟同态加密计算协议，从而能够实现如下几点安全要求：

1. 服务端可信区的SGX生成公私钥对，利用密封技术将私钥封存在本地，除了此平台的CPU，其它任何实体都无法获得私钥的内容。
2. 客户端认证服务端后，利用数字信封的形式，交换会话密钥，从而客户端与服务端可信区之间能够建立安全会话。
3. 所有数据的加解密操作，都在客户端以及在服务端的SGX内完成(包括文本的上传、下载、删除、搜索等等)，在网络传输以及服务端的不可信区，传输的都是密文数据，避免了恶意的主动攻击与被动攻击，而可信区的内容是受硬件保护的。

​		在上述第二步中，关于客户端如何获取服务端的认证，我们主要使用了Intel的远程认证技术。当作为可信第三方的公信机构向服务端发起挑战时，服务端的SGX会生成一份报告，这份报告包含了SGX环境的度量以及其中运行程序的度量等等，并交由可信第三方进行验证。利用Intel公司提供的群签名技术EPID，可信第三方可确认这份报告的真实性，从而相信接受挑战的服务商确实是在SGX平台上运行代码，而且运行的代码是未经篡改且可信的，因此可信第三方颁发给服务商一张证书。服务端利用这张证书，可以使用户相信其的真实性，从而完成认证，双方建立通信。

#### 2.1.2 系统功能

| 序号 |                     功能描述                     |
| :--: | :----------------------------------------------: |
|  1   | 用户与服务端可信区建立会话密钥，并完成注册、登录 |
|  2   |      用户上传数据，支持TXT、PDF、DOCX的上传      |
|  3   |       用户可进行数据的下载、删除、在线浏览       |
|  4   |             用户可进行关键词全文搜索             |
|  5   |                  支持回收站功能                  |

其中搜索包含以下功能（所有的功能可以组合进行）：

|        输入         |                    说明                    |
| :-----------------: | :----------------------------------------: |
|       pattern       |         全文搜索包含pattern的文本          |
|  pattern1 pattern2  |    全文搜索包含pattern1或pattern2的文本    |
|      -pattern       |        全文搜索不包含pattern的文本         |
| +pattern1 -pattern2 | 全文搜索包含pattern1，不包含pattern2的文本 |
|      pattern*       |       *匹配任意个字符，进行全文搜索        |
|      pattern?       |        ?匹配一个字符，进行全文搜索         |
|    pattern[abc]     |      [abc]匹配a、b、c其中的任一个字符      |
|  开启模糊搜索按钮   |      匹配5个相似的字符，进行全文搜索       |

### 2.2 技术原理

#### 2.2.1 TEE与SGX技术

> TEE、SGX技术介绍，Rust SGX SDK（选择Rust的理由）

##### 2.2.1.1 TEE

​		可信执行环境(TEE)是 Global Platform(GP)提出的概念。TEE 是 Trusted Execution Environment 的缩写，即可信执行环境。通常用于需要进行安全计算或者 敏感数据保护等等应用场景，TEE 作为一个安全计算保护技术，其实现原理需要受硬件机制的保护，TEE 通常隔离于其所在的应用程序，应用程序只能通过特定的入口与 TEE 进行通信。另外，TEE 内部程序具有访问外部内存的权限，而外部无法访问受硬 件保护的 TEE 专属内存地址空间。TEE 内执行的程序运行也将受到硬件级别的保护， 以避免其受到高权限恶意软件的干扰与篡改。

​		TEE 技术在实现上有诸多方案，例如应用于安全智能设备及移动嵌入式平台上的 ARM 的 TrustZone 等，本项目所采用的为当下 TEE 的适用范围最广的实现方案，即 Intel 公司的软件防护扩展(Software Guard Extensions SGX)技术，该技术为 Intel 架构新的扩展，在原有架构之上增加了一组新的指令集和内存访问机制，这些扩展允许应用程序实现一个被称为Enclave 的容器，在应用程序的地址空间中划分出一块被保护的区域，为容器内的代码提供机密性和完整性的保护，免受拥有特殊权限的恶意软件的破坏。

##### 2.2.1.2 SGX架构简介

​		英特尔® Software Guard Extensions（英特尔® SGX）是一组指令，该组指令增强应用程序代码和数据的安全性，为它们提供更强的保护以防泄漏或修改。开发人员可将敏感信息分区进入围圈中，围圈是内存中具有更强安全保护的执行区域。

​		下图给出了 Intel SGX 的基本架构[5]。

![img](http://www.jos.org.cn/html/2018/9/PIC/rjxb-29-9-2778-1.jpg)

<p align="center"> Intel SGX 架构</p>



​		英特尔SGX的实施可以总结为以下几点：

1. 应用程序分为两部分：安全部分和非安全部分；
2. 应用程序启动安全区，该安全区放置在受保护的内存中；
3. 当一个安全区域函数被调用时，只有安全区域内的代码才能看到其数据，外部访问总是被拒绝（包括有特权的系统代码、操作系统、BIOS等等）；返回时，安全区数据将保留在受保护的内存中。

<img src="../image/image-20210430213634536.png" alt="image-20210430213634536" style="zoom:50%;" />



##### 2.2.1.3 Enclave的特性

​		在SGX中，最核心的概念之一便是Enclave，其本质上是一块受保护的内存，用于存放应用程序敏感数据和代码[7].SGX允许应用程序指定需要保护的代码和数据部分, 在创建Enclave之前, 不必对这些代码和数据进行检查或分析, 但加载到Enclave中去的代码和数据必须被度量.当应用程序需要保护的部分加载到Enclave后, SGX保护它们不被外部软件所访问.Enclave可以向远程认证者证明自己的身份, 并提供必需的功能结构用于安全地提供密钥.用户也可以请求独有的密钥, 这个密钥通过结合Enclave身份和平台的身份做到独一无二, 可以用来保护存储在Enclave之外的密钥或数据。

​		所有的Enclave都驻留在EPC(Enclave page cache)中, 这是系统内一块被保护的物理内存区域, 用来存放Enclave和SGX数据结构[8].EPC布局由平台具体实现决定, 如果CPU支持SGX架构并在加密保护的DRAM (dynamic random access memory)中实现EPC, 那么它也支持BIOS保留一段叫PRM(processor reserved memory)的内存范围.BIOS通过配置一组范围寄存器分配PRM.具体的PRM和EPC布局和平台有关, 并取决于BIOS设置, 下图是一个PRM和EPC布局的例子。

![img](http://www.jos.org.cn/html/2018/9/PIC/rjxb-29-9-2778-2.jpg)

​		而Enclave具有如下特征.

1. 具有自己的代码和数据
2. 提供机密性保护
3. 提供完整性保护
4. 具有可控的入口点
5. 支持多线程
6. 对应用程序内存具有最高访问权限

##### 2.2.1.4 Enclave的安全机制

​		针对Enclave的保护机制主要包括两个部分:一是Enclave内存访问语义的变化, 二是应用程序地址映射关系的保护, 这两项功能共同完成对Enclave的机密性和完整性的保护。

1、内存访问语义

​		在系统内分配一块被保护的物理内存区域EPC, 用来存放Enclave和SGX数据结构[[9](http://www.jos.org.cn/html/2018/9/5594.htm#b9)].必须保证内存保护机制在物理上锁住EPC内存区域, 将外部的访问请求视为引用了不存在的内存, 使得外部的实体(直接存储器访问、图像引擎等)无法访问.对于使用MOV等指令访问Enclave内部的页面的情况, 硬件将执行下列的检查.

(1) 处理器当前运行在Enclave mode中;

(2) 访问地址在Enclave地址空间;

(3) 物理地址在EPC内存中;

(4) EPCM(Enclave page cache map)检查, 请求访问的页属于正在运行的Enclave(只有Enclave内的代码才能访问该Enclave的内容).

​		系统在SGX调用前, 必须处于保护模式, 且需要支持分页.SGX所提供的内存保护机制, 在保护模式所提供的段保护、页保护机制基础上进行进一步的内存保护, 访问地址由虚拟地址转换为物理地址进行访问。

![img](http://www.jos.org.cn/html/2018/9/PIC/rjxb-29-9-2778-4.jpg)

<p align="center"> SGX的内存访问控制</p>

2、地址映射保护

​		EPC内存以页为单位进行管理, 页的控制信息保存在硬件结构EPCM里, 一个页面对应一个EPCM表项, 类似于操作系统内的页表, 管理着EPC页面的基本信息, 包括页面是否已被使用、该页的拥有者、页面类型、地址映射和权限属性等[10].EPCM结构在CPU地址映射过程中用于执行Enclave页面的访问控制, 逻辑上而言, 它在保护模式的段保护和页保护机制的基础上增加了一层安全的访问控制.EPCM结构由PMH(page miss handler)硬件模块访问, 这个模块通过查询页表(系统软件维护的)、范围寄存器、EPCM来进行内存访问.EPCM逻辑结构图如下图所示：

![img](http://www.jos.org.cn/html/2018/9/PIC/rjxb-29-9-2778-5.jpg)

<p align="center"> EPCM的逻辑结构</p>

##### 2.2.1.5 Enclave机密性和完整性的保护

​		Enclave 对于安全容器内的代码和数据使用的保护机制主要包括两个部分：一是 Enclave 内存访问语义的变化，二是应用程序地址映射关系的保护，这两项功能共同 完成对 Enclave 的机密性和完整性的保护。
 1，SGX Enclave 的机密性保护

​		SGX 技术支持在系统内分配一块被保护的物理内存区域 EPC，用于存放 Enclave 和 SGX 数据结构，保证内存保护机制能够在物理上锁住 EPC，将外部的访问请求视为 引用了不存在对的内存，对于使用 MOV 等指令访问 Enclave 内部的页面的情况，硬件 将执行一系列严格的检查，确保处理器运行与 Enclave 模式，且请求访问的页属于正 在运行的 Enclave。从而保证了只有 Enclave 内部的代码才能够访问该 Enclave 的内 存。由于上述保护机制由 Intel 硬件实现，因此能够很好的实现 TEE 的要求。

​		另一方面，对于 EPC 内存，SGX 技术支持将其以单独的页为单位进行管理，并建 立硬件结构 EPCM 作为页表，管理 EPC 页面的基本信息，包括该页面是否已经被使用 等。逻辑上而言，这种基于硬件实现的独特的应用程序地址映射关系在保护模式的段 保护和页保护的基础上增加了一层安全的访问控制。

2，SGX Enclave 的完整性保护
 		SGX 技术使用 Enclave 度量机制对 Enclave 中代码和数据的完整性进行保护，即应用程序在创建 Enclave 时，将对每个添加的页面内容进行度量，得到一个创建序列 的度量结果，保存在 Enclave 控制结构中，随后 SGX 通过一条初始化指令将这个结果 与 Enclave 所有者签名的证书中的完整性值进行比较，如果匹配，将证书中所有者的 公钥进行哈希，作为密封身份保存在 Enclave 的控制结构中，如果不匹配，则说明在 创建过程中存在问题，如被攻击者篡改了程序数据或代码等，返回失败结果。

​		另一方面，SGX 技术同时提供了对于机密数据的持久化存储保护机制，即 SGX 数据密封技术(SGX data seal/unseal)。当 Enclave 初始化完成并运行时，由于前述 的机密性和完整性保护机制，能够为安全区内的数据提供保护，而如果在 Enclave 中 的秘密数据由于将来使用的需要必须被持久化存储，那么它必须在 Enclave 关闭之前 那储存在 Enclave 的边界之外。为了保护和持久化数据，提供了一种由 Enclave 软件 从特定的 Enclave 中提取 key 的机制。这个 Key 只能在特定的平台上被某个 Enclave 生成。Enclave 软件使用那个 key 去在平台上加密数据或者从平台上解密已经存在的数据。本项目中，计算节点 TEE 使用该数据密封技术来密封生成的私钥，以保证其安全和不泄露。

##### 2.2.1.6 Rust SGX SDK

​		Intel官方提供的SDK是使用C/C++进行编写的，由于这些语言的特性，传统的内存安全漏洞仍然存在，而在SGX中内存资源非常重要。百度安全实验室发起的开源项目Rust SGX SDK，通过将Rust语言与SGX技术进行结合，既利用了Rust内存安全的语言特性，也提供给了我们一个使用Rust进行SGX开发的选择。

​		如下图所示，Rust SGX一共分为三层，底层为Intel SGX SDK，是原生实现；而中间层是Rust和C/C++的 FFI（Foreign Function Interfaces）；最后上层是 Rust SGX SDK。

<img src="../image/截屏2021-05-09 下午1.25.35.png" alt="截屏2021-05-09 下午1.25.35" style="zoom:20%;" />

​		我们之所以使用这个开源框架，而不是Intel提供的原生SDK，主要基于以下几点理由：

1. SGX中内存非常受限。一个典型的Enclave上限值是256 Mb的内存，在这样的背景下，内存泄漏成为了最致命的问题，可能并不多的内存泄漏就会导致程序运行速度大幅减慢，甚至产生系统崩溃等严重后果。相对C与C++，Rust能够很好地保障内存安全。

2. SGX中的程序调试不方便，而Rust由于其强大的编译器，可以在编译阶段检查出大部分的错误，可以弥补SGX调试的不足。
3. 由于Rust标准库（std）的可插拔性，所以Rust对嵌入式程序有天然的友好，而开发SGX程序和开发嵌入式程序的过程其实是相似的。从另一种角度说，这一特性使得Rust程序向SGX环境的移植比较方便，这也是我们移植使用Rust编写的文本搜索引擎Tantivy的出发点。

#### 2.2.2 文本搜索引擎Tantivy

> Tantivy索引组织方式，打分算法BM25等等

​		Tantivy是一个基于Rust平台的开源搜索引擎库，衍生于搜索引擎Lucence。原生的tantivy以及有不错的性能，支持索引建立，查询，多线程执行等操作。在本项目中，我们将Tantivy移植到SGX内，使得SGX内部能够很好的去调用搜索引擎。并且我们还对tantivy内部进行了一定的优化与改进，以适配我们的使用环境以及应用场景。具体的改动在2.3.1中会有详细的描述。

​		Tantivy建立的索引为倒排索引，在Tantivy中存放在`.idx`文件内。它从词出发，记载了这个词在哪些文档中出现过，由两部分组成——词典和倒排表，其中倒排表内存有各自出现过的文章。一般而言倒排索引的内容为`term->[doc id1,doc id2...]`。 而tantivy内的索引表增加了frequency， 是词在文章内占有的数量。所以tantivy对倒排索引表的存储格式为`term->[(doc id1,frequency1),(doc id2,frequency2)...]`。

![](../image/invertidx.png)

​		倒排索引在存储前先使用了编码。`Doc id`可能往往会非常庞大，因为文章的数量多。而它们在倒排索引表内，都是事先从小到大排列好的，因为先建立文档，`Doc id`就越小。所以在Tantivy中，倒排索引内的`Doc id`并不是用绝对的编号，而是用相邻只差来表示。

​		但Tantivy的索引建立和搜索也有一些缺陷。Tantivy会先把建立的索引先放在内存当中，当在内存中的索引体积到达一定大小的时候，才会flush到磁盘内部。但是在内存没有被flush的时候，Tantivy是无法搜索的。

​		Tantivy原生的打分是使用了向量空间模型算法，调用与Lucence的TF-IDF。所以Tantivy能使用打分机制来决定文章对于搜索词汇的相关程度。能够向用户推送关联度更高的文章。

#### 2.2.3 其它技术

> 密码学算法、HTTPS

rsa, aes, https, 网页端脚本

### 2.3 系统实现

​		本项目实现了一个基于TEE的全文搜索系统，用户可将自己的文件上传至服务端，并进行在线浏览、下载、删除、复杂搜索等等，在保证安全性的同时提供了极高的性能，解决了传统云服务商不可信的问题，即能实现“你可以用我的服务，但不用相信我”。

​		首先，我们将文本搜索引擎Tantivy迁移至SGX环境，并根据SGX环境的特性，对Tantivy进行全面的修改与优化，包括索引建立的改进、倒排索引SGX的实现、打分算法的升级等等，这将在第2.3.1节进行介绍。

​		为了保证系统的安全性，仅仅依靠SGX的保护是不够的，因为SGX对输入没有要求。为了能够实现客户端与服务端可信区的安全通信，必须先完成认证，然后实现会话密钥交换，这将在第2.3.2节介绍。

​		服务端与客户端的介绍分别在第2.3.3节与2.3.4节进行，以下为系统实现架构图。

<img src="../image/image-20210507165249382.png" alt="image-20210507165249382" style="zoom:50%;" />

#### 2.3.1 Tantivy的移植与性能改善

##### 2.3.1.1 索引建立的改进

​		上面提到，Tantivy会先把建立的索引先放在内存当中，当内存中的索引表没有被flush之前，Tantivy都无法提供搜索服务。所以在移植到SGX内时，我们对索引建立过程进行了优化。因为我们的云盘服务是用户直接上传几个文件，而不是连续不间断上传多个文件。所以我们设定，当用户上传完一个文件后，无论文件的大小，后端都自动flush所有内存到磁盘中。以确保用户后续的体验。

​		为了实现这个过程，我们使用的函数为Tantivy内部的`commit()`函数。可以手动冲刷内存区域到磁盘中。配合文章建立函数`add_document()`，使得文章能够完整载入，可以做到传输上传一体化，增加了用户的操作体验以及后续开发的流畅度。

​		并且在Tantivy移植SGX中，我们去掉了对于磁盘的监控。因为Tanvtivy会有对内存和磁盘的监控能力。为了防止自动flush，我们关闭了监控功能。这时我们就可以只用flush一次就能够全部将索引载入。

##### 2.3.1.2 倒排索引的SGX实现

​		Tantivy中对于倒排索引代码实现是，每一个term的倒排索引都是独立的。可以看出，如此多的文章包含巨量的索引表，如果完整展现，一是会在建立索引的一瞬间CPU需要开辟大量的空间，二是不可能包含所有文章内出现的词汇。而rust不支持动态的全局变量，导致要么我们只能静态开启所有可能的term表，要么在处理时使用`unsafe` 结合指针来回传递地址。前者导致若遇到新的term就会丢弃，导致搜索不准确。后者使代码健康性下降，并且增加CPU额外处理。

​		对此，我们遵循Tantivy开辟倒排索引的思想使用rust的lazy库。只有当一个新的term出现的时候，计算机才会开辟一块空间作倒排索引，这非常好理解。使用rust的`lazy`库定义的变量，只有在系统调用或定义时才会被赋值，这很好了解决了我们只有来新term才开辟空间的理念。

##### 2.3.1.2 采用BM25算法

​		传统的TF值理论上是可以无限大的。而BM25与之不同，它在TF计算方法中增加了一个常量k，用来限制TF值的增长极限。对此我们将传统TF-IDF，一种向量空间模型算法，替换成目前广泛运用的BM25算法。 下面是两者的公式：
$$
传统的TF\ : \ \ \ \ \ \ \  Score = \sqrt {tf}\\
BM25的TF\ : \ \ \ \ \ \ Score = \frac{(k+1)*tf}{k+tf}
$$
​		BM25相比TF-IDF的好处是，BM25的TF Score会被限制在0~k+1之间，它可以无限逼近k+1，但永远无法触达它。这符合我们的逻辑认知，因为文章的相关度永远都不会超过100%。而传统TF打分会随着term frequent增加而增加，不符合我们对文本相关性逻辑的理解。

​		从图中可以看到TF-IDF和BM25对词频与打分的增长趋势。 我们在此项目中设置k值为2。

<img src="../image/bm25.png" style="zoom:30%;" />

#### 2.3.2 拟同态加密计算协议

> 证书颁发+认证+会话密钥协商

​		由1.2.1节分析可知，为了实现隐私保护的文本存储与搜索服务，传统的密码学方案均有着较大的弊端。比如使用全同态加密，虽然可以实现任意多次运算以及任意复杂的运算，但是它的时间复杂度极高，这样的运算延时对于用户来说是不可接受的。而利用可搜索加密，虽然运算效率高，但是支持的运算有限，诸如模糊搜索等功能都是难以实现的。依此可见，这些传统的方案始终无法兼得较高的性能与丰富的功能。而通过在云服务端部署可信执行环境TEE，通过硬件保护的机制，既能实现极高的计算精度，又能实现极好的计算性能，因此能够在保障安全的同时，为用户提供隐私保护的服务。然而，由于TEE本身并不对数据的输入作要求，即只是提供了一个受硬件保护的安全平台，因此还需要一个安全的通信协议的支持。

​		TEE能够保证其内的明文数据无法被服务商窃取，而无法保证TEE外的数据的安全性，因此TEE外的数据必须是密文。这些密文数据输入TEE后，在可信区内进行解密操作。加解密的密钥来源于客户端与服务端可信区的会话协商，因此这涉及客户端认证服务端的过程。为了实现这一过程，我们分析了当下存在的各类隐私保护计算的解决方案以及各类有安全认证功能的通信协议，综合考量了安全、性能、功能，同时借助Intel的远程认证技术以及数据本地密封技术，实现了拟同态加密计算协议。

​		首先，对建立通信的流程进行介绍，建立通信的流程图如下所示。

<img src="../image/截屏2021-05-03 下午3.19.28.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />

​		通信主要分为两个步骤，即证书颁发和认证加密。其中证书颁发的过程只需在服务启动时进行即可，而认证加密的过程是一次性的，即用户断开会话连接后，想要再次获取服务，必须再一次进行认证加密过程。

---

**证书颁发**

1. 基于RSA 2048bits公钥算法，服务商在可信区内生成一对公私钥，其中使用Intel 密封技术，将私钥封存在本地。
2. 可信第三方，例如政府等公信机构，向服务商发起挑战。
3. 在云服务商的可信区内，生成一份报告，这份报告包含了当前运行的SGX环境的测度以及运行在可信区的代码的测度等等，并将这份报告利用Intel 远程认证技术交给第三方。
4. 可信第三方获取Intel的服务，验证这份报告的真实性，从而判断云服务商是否存在SGX环境，以及运行的代码是否是未经篡改、真实可信的。
5. 若验证通过，可信第三方向云服务商颁发一张受信任的证书，这张证书包含在第一步生成的公钥。

**认证加密**

1. 若用户想要获取服务，则在登录或注册之前，自动进行认证加密的过程。
2. 服务端可信区将上述证书发送给客户端。
3. 客户端验证这张证书的真实性，若验证通过，则生成一个随机数，作为会话密钥。
4. 客户端使用证书中的公钥，对上述随机数进行加密，并发送给服务端可信区。
5. 服务端可信区获取封存的私钥，对收到的数字信封进行解密，得到随机数。
6. 双方将上述随机数作为加密会话的密钥，加密算法为AES 256bits CBC。

---

​		在此，对上述步骤中运用的重要技术，即远程认证与数据密封，进行简要说明。Intel在制造每一个CPU时，在里面刻录了两个秘密，分别是”Provisioning Secret“以及”Seal Secret“，其中前者是此CPU与Intel共享的秘密，而后者只有此CPU可以获取。因此服务商的CPU利用这两个秘密生成一个对称密钥，由于这个密钥只有此计算机的CPU才能导出，利用这个密钥加密数据，即可实现本地安全存储的功能。而由于”Provisioning Secret“是服务商与Intel共享的，因此借助这个秘密，服务商可以向Intel证明自己的SGX环境，这也是远程认证实现的基础。具体实现原理可参见Intel SGX的官方文档，在此不再赘述。

​		在上述建立的通信流程的基础上，以下对拟同态加密计算协议进行数学描述，首先对使用到的函数、符号进行说明。

|          函数及符号          |                说明                |
| :--------------------------: | :--------------------------------: |
| $pubK_{SGX},\ \  priK_{SGX}$ |        SGX内生成的公私钥对         |
|       $SGX(operation)$       |          SGX内进行的操作           |
|             $k$              | 客户端与服务端可信区建立的会话密钥 |
|         $Seal(data)$         |        Intel提供的密封技术         |
|        $Unseal(data)$        |        Intel提供的解封技术         |
|           $Data_u$           |           用户上传的数据           |
|           $Data_s$           |        服务端保存的用户数据        |
|       $E_{key}(data)$        |   使用密钥key对数据data进行加密    |
|       $D_{key}(data)$        |   使用密钥key对数据data进行解密    |
|            $user$            |              用户标识              |

​		以下对拟同态加密计算协议的具体流程进行说明。

---

**SGX密钥生成**

1. 服务端可信区SGX内生成公私钥对：
   $$
   SGX(pubK_{SGX},\ \  priK_{SGX})
   $$

2. 利用密封技术，将私钥 $priK_{SGX}$ 封存在本地，与硬件CPU绑定在一起：
   $$
   data_1 = SGX(Seal(priK_{SGX}))
   $$

**协商密钥**

3. 客户端验证证书，得到SGX公钥$pubK_{SGX}$。

4. 生成随机数$k$，作为对称加密的密钥。

5. 使用SGX公钥加密随机数，并发送给服务端：
   $$
   data_2 = E_{pubK_{SGX}}(k)
   $$

6. 客户端获取本地封存的私钥，并解密$data_2$，获得会话密钥
   $$
   priK_{SGX} = SGX(Unseal(data_1))\\
   k = SGX(D_{priK_{SGX}}(data_2))
   $$

**模拟同态计算**

7. 客户端至服务端

   * 客户端对用户输入的数据使用会话密钥$k$进行加密，利用用户标识$user$区分不同用户：

   $$
   data_3 = E_k(Data_u||user)
   $$

   * 服务端SGX内对上述数据进行解密，识别用户$user$，并对用户的数据$Data_u$进行相应操作：
     $$
     Data_u||user=SGX(D_k(data3))
     $$

8. 服务端至客户端

   * 如用户进行查询等操作，服务端从本地取出需要查询的数据$Data_s$，使用会话密钥$k$加密，发送给用户：
     $$
     data_4 = SGX(E_k(Data_s))
     $$

   * 客户端对上述数据进行解密，得到需要的数据：
     $$
     Data_s = D_k(data_4)
     $$

---

​		因此，利用我们设计的拟同态加密计算协议，能够实现客户端与服务端可信区的安全通信。客户端数据的安全性由用户保证，服务端可信区的安全性由Intel保证，而在传输的其它步骤中，所有数据都是以密文的形式进行呈现，因此在我们的威胁模型中，云服务商可以是不受信任的。

#### 2.3.3 服务端实现

##### 2.3.3.1 服务端不可信区

​		服务端的不可信区主要使用了Web框架Beego以及关系型数据库MySQL。Beego是一个使用Golang开发的Web框架，受RESTful支持并采用MVC模型，适合应用于大量高并发的产品中。而MySQL是一个高性能、可靠性好的开源关系数据库管理系统。

​		服务端的不可信区一方面作为中间层，连接客户端以及服务端的SGX，提供传递数据的作用；另一方面，进行数据库的存取，比如将使用SGX公钥加密后的用户口令存储于不可信的数据库等等。下表是该层实现的接口以及调用方法，客户端需要访问表中的接口实现预期的功能。

|    接口     | 方法 |                      说明                      |
| :---------: | :--: | :--------------------------------------------: |
| session_key | GET  |    认证与会话密钥协商，在登录或注册之前完成    |
|  register   | POST |                    用户注册                    |
|    login    | GET  |                    用户登录                    |
|   logout    | GET  |                    用户退出                    |
|   upload    | POST |    用户上传文档，支持的格式为TXT、PDF、DOCX    |
|    query    | GET  |      用户输入关键字进行查询，返回结果列表      |
|    show     | GET  | 对上传的文档进行在线浏览，下载功能也调用此接口 |
|   delete    | POST |                  删除某篇文档                  |
|     bin     | POST |                   清空回收站                   |
|   recover   | POST |             从回收站中恢复某篇文章             |

​		由于在中间层中几乎所有数据都是以密文的形式进行呈现，一方面保障了安全性，另一方面使得大多数的逻辑操作都无法进行，因此这一层的存在只是起到将可信区的功能以接口的形式暴露给客户端的作用。

##### 2.3.3.2 服务端可信区

​		服务端的可信区的实现主要使用了开源框架Rust SGX SDK以及文本搜索引擎Tantivy，这些的介绍以及改进在之前的章节中已有详细说明，在此不再赘述。

​		实现了SGX的CPU有两种工作模式，一种运行于安全世界，也就是CPU正在运行可信区Enclave内的代码；另一种工作模式运行于非安全世界，也就是CPU正在运行非可信区Enclave外的代码。这两种工作模式的切换所涉及到的函数是可信区开发的关键，以下对这些定义在“Enclave定义语言文件(EDL)”中的部分函数，进行重点说明。

```c
public sgx_status_t server_hello([out, size=result_max_len] uint8_t* pk_n, size_t pk_n_len,
                    [out, size=result_max_len] uint8_t* pk_e, size_t pk_e_len,
                    [out, size=result_max_len] uint8_t* certficate, size_t certficate_len,
                    size_t result_max_len );
此函数的功能是处理客户端的请求。当用户希望使用服务时，在客户端发起注册或登录，在登录或注册前自动调用该函数，从而使得客户端可以得到服务端可信区的证书certificate。
```

```c
public sgx_status_t get_session_key(
    [in, size=enc_pswd_from_db_len] const uint8_t* enc_pswd_from_db, 
    size_t enc_pswd_from_db_len, 
    [in, size=enc_data_len] const uint8_t* enc_data, 
    size_t enc_data_len 
);    
此函数的功能是获得会话密钥以及处理用户登录。若客户端验证证书通过，则以数字信封的形式将会话密钥传递给服务端可信区。该函数首先对于用户输入的口令(使用上述会话密钥加密)与从数据库取出的口令(使用SGX公钥加密)进行解密比对，以判断用户是否输入了正确的口令。如果输入正确，则使用数据结构HashMap对用户标识以及该用户关联的会话密钥进行存储：
keymap: Mutex<HashMap<String, [u8;32]>> = Mutex::new(HashMap::new());
```

```c
public sgx_status_t user_logout([in, size=len] const uint8_t* some_string, size_t len);
此函数的功能是对存储在HashMap中的属于该用户的键值对删除
```

```c
public sgx_status_t build_index([in, size=len] const uint8_t* some_string, size_t len);
此函数的功能是对用户上传的数据进行索引的构建。首先对用户传入的数据包使用会话密钥解密，接下来将它由JSON格式转化对象，并提取出信息形成如下的索引输入结构：
struct DBInput {
    id: String,						// 文本标题
    user: String,					// 用户名
    text: String,					// 文本内容
    user_id: String,			// 用户ID
    time: String,					// 用户上传的时间
    isdeleted: String,		// 此文本是否已被放入回收站中
}
在可信区内已使用Tantivy建立了如下的索引结构：
schema_builder.add_text_field("id", STRING | STORED);
schema_builder.add_text_field("user", STRING | STORED);
schema_builder.add_text_field("text", TEXT | STORED);
schema_builder.add_text_field("user_id", STRING | STORED);
schema_builder.add_text_field("time", STRING | STORED);
schema_builder.add_text_field("isdeleted", STRING | STORED);
将用户的输入数据写入索引，关键代码如下：
let input_string = serde_json::to_string(&db_input).unwrap();

let doc = match schema.parse_document(&input_string) {
    Ok(doc) => doc,
    _ => {
        return sgx_status_t::SGX_ERROR_UNEXPECTED;
    }
};

let index_writer_clone_1 = index_writer.clone();
index_writer_clone_1.read().unwrap().add_document(doc);
```

​		以上索引结构，对应于数据库表格的形式，即为如下：

|  id  | user | text | user_id | time | isdeleted |
| :--: | :--: | :--: | :-----: | :--: | :-------: |
| ...  | ...  | ...  |   ...   | ...  |    ...    |


```c
public sgx_status_t do_query([in, size=len] const uint8_t* some_string, size_t len, 
                            [out, size=result_max_len]uint8_t * encrypted_result_string, 
                            size_t result_max_len, size_t isFuzzy );
此函数的功能是对用户输入的关键词进行全文搜索，其中参数 isFuzzy 用于判断是否开启模糊搜索功能。首先对用户输入的关键词使用会话密钥解密。接下来按照此关键词进行全文搜索，其中开启模糊搜索功能的关键代码如下：
if isFuzzy==1 {
  let text = schema.get_field("text").unwrap();

  let term = Term::from_field_text(text, &pattern);
  let query = FuzzyTermQuery::new(term, 2, true);

  top_docs = searcher.search(&query, &TopDocs::with_limit(100));  //搜索相关函数
}
```

#### 2.3.4 客户端实现

​		客户端界面采用的前端框架是Bootstrap，这一开源框架提供了丰富的工具与美观的界面。

​		客户端与服务端的通信主要采用AJAX的方式实现，AJAX是异步的JavaScript与XML技术，与传统的使用表单形式的Web应用不同，AJAX可以仅向服务器发送并取回必须的数据，并在发送前或取回后使用JavaScript进行处理，这一点对于我们要在客户端对数据进行加解密是极其重要的。除此之外，AJAX使得Web应用的响应更加迅速。

​		客户端JavaScript实现的函数都采用AJAX的形式与后端进行通信，除了认证与协商密钥相关的函数外，其它所有函数都在向服务端发送数据前对数据进行加密，得到服务端返回的数据后对其进行解密。以下表格对所有函数进行说明。

|     函数      |                          说明                          |
| :-----------: | :----------------------------------------------------: |
|  register()   |     处理用户注册，首先完成服务端认证与会话密钥协商     |
|    login()    |     处理用户登录，首先完成服务端认证与会话密钥协商     |
|   logout()    |                      处理用户退出                      |
| uploadFile()  |              处理上传文本以及相关格式问题              |
|    query()    | 处理用户输入的关键词，并处理返回的结果列表，在页面展示 |
|    show()     |       处理用户输入，对返回的文本内容进行在线展示       |
|  download()   |           处理用户输入，对返回的文本进行下载           |
|   delete()    |          处理用户输入，使得相应文本放入回收站          |
|  empty_bin()  |        清空回收站，使得回收站内的文本被彻底删除        |
| recover_bin() |         处理用户输入，使回收站内的文本得以恢复         |

​		下面对我们实现的系统的交互界面进行介绍。



## 3 作品测试与分析

​		本次测试采用search-benchmark-game这一开源框架针对tantivy-SGX和不同的搜索引擎进行性能比较。search-benchmark-game是一个标准的用于比较各中搜索引擎各方面速度的测试框架。目前标准的框架仅支持Lucene和tantivy两类搜索引擎的测试，同时用户可以自定义添加其他的搜索引擎。其测试结果界面如图3-1所示.

<img src="../image/3-1.png"  style="zoom:50%;" />

<center> 图 3-1

### 3.1 测试环境

##### 3.1.1 客户端

<center>表3-1客户端测试设备参数

| 项目     | 配置参数值                                        |
| -------- | :------------------------------------------------ |
| 操作系统 | Windows 10                                        |
| CPU      | AMD Ryzen 9 4900HS with Radeon Graphics  3.00 GHz |
| 内存     | 8.00GB 3200MHz DDR4 *2                            |
| 磁盘     | 1.0TB                                             |
| 网络连接 | 以太网                                            |

##### 3.1.2 服务器端

<center> 表3-2 服务端测试设备参数</center>

| 项目     | 配置参数值                                |
| -------- | ----------------------------------------- |
| 操作系统 | Ubuntu 20.04                              |
| CPU      | Intel (R) Core(TM) i7-9700 CPU @ 3.00 GHz |
| 内存     | 4.00GB 2666MHz DDR4 *4                    |
| 磁盘     | 500GB 7200r                               |
| 网络连接 | 以太网                                    |

### 3.2 功能测试

* 主界面如图3-2所示，按照上传时间排序用户上传的文件：

<img src="../image/index.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />

<center> 图3-2 主界面</center>

* 搜索界面如图3-3所示，搜索结果按照BM25打分算法得分排序。

  <img src="../image/3-3.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />

<center> 图 3-3 搜索界面 </center>

* 模糊搜索如图3-4所示：

  <img src="../image/3-4-2.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />
  
  <center> 图 3-4 模糊搜索界面 </center>
  
* 取各搜索pattern的并集：

  <img src="../image/3-5-1.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />
  
  <center> 图 3-5 模糊搜索界面 </center>
  
* 指定结果中的关键词，+pattern1 -pattern2，其中pattern1是搜索结果中必须包含的关键字，pattern2是搜索结果中不包含的关键字：

  <img src="../image/3-6-1.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />

  <center> 图 3-6 +pattern1 -pattern2 界面 </center>

* 通配符搜索，pattern*，匹配给定字符后的0个或多个字符，给出对应的搜索结果：

  <img src="../image/通配符1.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />

  <center> 图 3-7 通配符pattern *搜索界面 </center>

* 通配符搜索，pattern?，匹配给定字符后的一个字符，给出对应的搜索结果：

  <img src="../image/通配符2.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />
  
  <center> 图 3-8 通配符pattern?搜索界面 </center>
  
* 下载界面如图3-9所示.

  <img src="../image/3-4.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />

<center> 图3-9 下载界面</center>

* 回收站界面如图3-10所示，提供清空回收站和回收站文件恢复功能。

  <img src="../image/3-5.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />

<center> 图 3-10 回收站界面</center>

### 3.3 性能测试

tantivy-SGX是本系统的核心部分，使用Search-benchmark-game进行测试，测试方法是给定查询关键词，计算搜索引擎给出查询结果的时间，并将其与lucene和tantivy的查询时间相比较。

性能测试的查询语料集来自于[AOL query dataset](https://en.wikipedia.org/wiki/AOL_search_data_leak),查询包括：

* intersection：针对不同关键字的查询结果的交集
* unions：针对不同关键字的查询结果的并集
* Phrase：查询单个关键词

并且各自给出三种查询结果：
* COUNT：仅计数匹配的文档数量，不进行打分
* TOP10：找出BM25算法打分最高的十个结果
* TOP10+COUNT：找出BM25算法打分最高的10个结果并且计数匹配的文本数量

测试在单线程中运行，测试结果仅保留五次运行中的最佳成绩。

<center> 表 3-3 phrase TOP10 查询结果比较 </center>

| 查询关键词个数 | tantivy-SGX | tantivy-0.13          | lucene-8.4.0 |
| :-: | :-: | :-: | :-: |
| 2              | 27μs | 13μs | 41μs |
| 3 | 28μs | 16μs | 56μs |
| >3 | 28μs | 18μs | 73μs |
| 平均值 | 28μs | 14μs | 47μs |

<center> 表3-4 intersection TOP10查询结果比较</center>

| 查询关键词个数 | tantivy-SGX | tantivy-0.13 | lucene-8.4.0 |
| :------------: | :-----------: | :------------: | :------------: |
|       2        | 34μs        | 15μs | 44μs |
|       3        | 39μs | 19μs | 53μs |
|       >3       | 46μs | 23μs | 61μs |
|     平均值     | 36μs | 17μs | 48μs |

<center> 表3-5 union TOP10查询结果比较 </center>

| 查询关键词个数 | tantivy-SGX | tantivy-0.13 | lucene-8.4.0 |
| :------------: | :---------: | :----------: | :----------: |
|       2        |    34μs     |     19μs     |     50μs     |
|       3        |    39μs     |     26μs     |     76μs     |
|       >3       |    47μs     |     38μs     |    142μs     |
|     平均值     |    36μs     |     22μs     |     63μs     |

<center> 表3-6 phrase queries COUNT查询结果比较 </center>

| 查询关键词个数 | tantivy-SGX | tantivy-0.13 | lucene-8.4.0 |
| :------------: | :---------: | :----------: | :----------: |
|       2        |    26μs     |     13μs     |     36μs     |
|       3        |    26μs     |     16μs     |     45μs     |
|       >3       |    27μs     |     19μs     |     49μs     |
|     平均值     |    26μs     |     14μs     |     39μs     |

<center> 表3-7 intersection COUNT查询结果比较 </center>

| 查询关键词个数 | tantivy-SGX | tantivy-0.13 | lucene-8.4.0 |
| :------------: | :---------: | :----------: | :----------: |
|       2        |    32μs     |     15μs     |     40μs     |
|       3        |    38μs     |     18μs     |     52μs     |
|       >3       |    46μs     |     25μs     |     69μs     |
|     平均值     |    35μs     |     16μs     |     45μs     |

<center>表3-8 union COUNT查询结果比较</center>

| 查询关键词个数 | tantivy-SGX | tantivy-0.13 | lucene-8.4.0 |
| :------------: | :---------: | :----------: | :----------: |
|       2        |    33μs     |     16μs     |     45μs     |
|       3        |    37μs     |     21μs     |     60μs     |
|       >3       |    45μs     |     28μs     |     71μs     |
|     平均值     |    35μs     |     18μs     |     51μs     |

<center>表3-9 phrase TOP10+COUNT查询结果比较 </center>

| 查询关键词个数 | tantivy-SGX | tantivy-0.13 | lucene-8.4.0 |
| :------------: | :---------: | :----------: | :----------: |
|       2        |    27μs     |     13μs     |     37μs     |
|       3        |    27μs     |     15μs     |     51μs     |
|       >3       |    27μs     |     18μs     |     54μs     |
|     平均值     |    27μs     |     14μs     |     42μs     |

<center> 表3-10 intersection TOP10+COUNT查询结果比较</center>

| 查询关键词个数 | tantivy-SGX | tantivy-0.13 | lucene-8.4.0 |
| :------------: | :---------: | :----------: | :----------: |
|       2        |    34μs     |     15μs     |     44μs     |
|       3        |    39μs     |     18μs     |     53μs     |
|       >3       |    50μs     |     24μs     |     59μs     |
|     平均值     |    36μs     |     16μs     |     47μs     |

<center> 表3-11 union TOP10+COUNT查询结果比较 </center>

| 查询关键词个数 | tantivy-SGX | tantivy-0.13 | lucene-8.4.0 |
| :------------: | :---------: | :----------: | :----------: |
|       2        |    33μs     |     21μs     |     45μs     |
|       3        |    39μs     |     28μs     |     67μs     |
|       >3       |    46μs     |     38μs     |     83μs     |
|     平均值     |    35μs     |     24μs     |     54μs     |

​		从上面几个表可以看出，query、intersection、union三种查询方式所需时间依次增加，并且，引入BM25打分算法之后相比之前搜索效率略有下降。总的来说，tantivy-SGX的搜索效率介于tantivy-0.13和lucene-8.4.0两者之间，可以认为我们在保证了安全性的同时兼顾了搜索效率，目前的时间复杂度足以满足大部分场景下的性能需求。三个搜索引擎平均搜索时间关系图如图3-11所示。

<center> 图3-11 搜索时间关系图 </center>

<img src="../image/3-6.png" alt="截屏2021-05-03 下午3.19.28" style="zoom:50%;" />

### 3.4 安全性分析

> 我们系统的安全性能保障，SGX面临的攻击



## 4 创新性说明

## 5 总结

### 5.1 工作总结

### 5.2 未来展望

## 6 参考文献

| [1]  | Song XD, Wagner D, Perrig A. Practical techniques for searches on encrypted data. In: Proc. of the IEEE Symp. on Security and Privacy. [IEEE Press, 2000. 44-55 ](http://dx.doi.org/10.1109/SECPRI.2000.848445). |
| ---- | ------------------------------------------------------------ |
| [2]  | Boneh D, Di Crescenzo G, Ostrovsky R, Persiano G. Public key encryption with keyword search. In: Camenisch LJ, Cachin C, eds. Proc. of the Advances in Cryptology—EUROCRYPT 2004. [LNCS 3027, Berlin: Springer-Verlag, 2004. 506-522 ](http://dx.doi.org/10.1007/978-3-540-24676-3_30). |
| [3]  | Feng DG, Zhang M, Zhang Y, Xu Z. Study on cloud computing security. Ruan Jian Xue Bao/Journal of Softwase, 2011,22(1): 71-83 (in Chinese with English abstract). [http://www.jos.org.cn/1000-9825/3958.htm](http://dx.doi.org/10.3724/SP.J.1001.2011.03958) |
| [4]  | LI Jing-Wei, JIA Chun-Fu, LIU Zhe-Li, LI Jin, LI Min. Survey on the Searchable Encryption[J]. Ruan Jian Xue Bao/ Journal of Software, 2015, 26(1): 109-128.http://www.jos.org.cn/1000-9825/4700.html |
| [5]  | Wang J, Fan CY, Cheng YQ, Zhao B, Wei T, Yan F, Zhang HG, Ma J. Analysis and Research on SGX Technology. Journal of Software, 2018, 29(9): 2778-2798(in Chinese).http://www.jos.org.cn/1000-9825/5594.htm |
| [6]  | Curtmola R, Garay J, Kamara S, Ostrovsky R. Searchable symmetric encryption: Improved definitions and efficient constructions. In: Proc. of the 13th ACM Conf. on Computer and Communications Security (CCS 2006). New York: ACM Press, 2006. 79-88. |
| [7]  | Prof. Dr. -Ing. Sadeghi AR. Trusted Execution Environments Intel SGX. Germany: Technische Universität Darmstadt (CASED). |
| [8]  | Intel Corporation. Intel® software guard extensions (Intel® SGX). Intel Labs., 2013. https://software.intel.com/sgx |
| [9]  | Intel Corporation. Intel® software guard extensions (Intel® SGX) SDK for Linux* OS., 2017. |
| [10] | Rich M. Intel software guard extensions (SGX) is mighty interesting. 2013. https://securosis.com/blog/intel-software-guardextensions-sgx-is-mighty-interesting |
| [11] | tantiy-doc. https://fulmicoton.gitbooks.io/tantivy-doc/content/ |

